#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require



#include "di_commons.h"
#include "../common.glsl"
#include  "../bsdf.glsl"
#include "../util.glsl"

#include "restir_di.glsl"


layout(location = 0) rayPayloadEXT HitPayload hitPayload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;

#include "../trace_common.glsl"

layout(push_constant) uniform _PushConstantRay { RestirDIPC pc_ray; };


void main()
{
    
    load_gbuffer();
    uint light_idx = spatial_reservoirs.r[pixel_idx].s.light_idx;
    
    if(light_idx == -1)
    {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0, 0, 0, 1));
        temporal_reservoirs.r[pixel_idx] = init_restir_reservoir();
        return;
    }

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    vec3 origin = (scene_ubo.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 target = scene_ubo.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = scene_ubo.viewInverse*vec4(normalize(target.xyz / target.w), 0);
    
   // vec3 color = gBuffer_normal;

    SurfaceScatterEvent event = make_surface_scatter_event(direction.xyz,gBuffer_normal, gBuffer_position, gBuffer_uv,gBuffer_material_idx);
    vec3 color = vec3(0);


    //   // debugPrintfEXT("light_idx: %d\n", light_idx);
    color += sample_specify_light(light_idx,event,true,false,seed);


    //  color = vec3(gBuffer_uv,0);
//
//
    RestirReservoir spatial_reservoir = spatial_reservoirs.r[pixel_idx];


    // debugPrintfEXT("spatial_reservoir.w_sum m light_num: %f %f %f\n", spatial_reservoir.w_sum, spatial_reservoir.m, pc_ray.light_num);
//   / color *= spatial_reservoir.w_sum/(length(color) * spatial_reservoir.m) * pc_ray.light_num;
    color *= spatial_reservoir.W * pc_ray.light_num;

    temporal_reservoirs.r[pixel_idx] = spatial_reservoir;
    //return ;


    //color =gBuffer_normal;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));

}
