#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require




#include "../common.glsl"
#include "path_commons.h"
#include "../util.glsl"

layout(location = 0) rayPayloadEXT HitPayload hitPayload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
layout(push_constant) uniform _PushConstantRay {PCPath pc_ray;};


#include "pt_commons.glsl"

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);

vec3 warp(vec3 v){
    return (v + 1.0f) / 2.f;
}

bool isBlack(vec3 v){
    return v.x == 0 && v.y == 0 && v.z == 0;
}


LightSample  uniform_sample_one_light(const vec4 u,inout SurfaceScatterEvent event ,const uint light_num){
    uint light_idx = uint(u.x * light_num);
    float light_choose_pdf = 1.0 / light_num;
    LightSample result = sample_li(light_idx,event,u.yzw);
    
//    if(result.pdf == 0 || isBlack(result.indensity)){
//        return result;
//    }
    
    //trace ray 
    any_hit_payload.hit = 1;
    traceRayEXT(tlas,
    gl_RayFlagsTerminateOnFirstHitEXT |
    gl_RayFlagsSkipClosestHitShaderEXT,
    0xFF, 1, 0, 1, event.p, EPS, result.wi, result.dist - EPS, 1);
    bool  visible = any_hit_payload.hit == 0;
    
    if(!visible){
        result.indensity = vec3(0);
        return result;
    }

    uint material_idx = event.material_idx;
    
    result.pdf *= light_choose_pdf;
    float bsdf_pdf;
    
    event.wi = to_local(event.frame, result.wi);
    result.indensity = result.indensity * eval_bsdf(materials.m[material_idx],event);
 
   // result.indensity = 
    return result;
}



void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = scene_ubo.viewInverse * vec4(0,0,0,1);
    vec4 target = scene_ubo.projInverse * vec4(d.x, d.y, 1, 1) ;
    vec4 direction = scene_ubo.viewInverse*vec4(normalize(target.xyz / target.w), 0) ;

    uint rayFlags = gl_RayFlagsOpaqueEXT; 
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 throughput = vec3(1.0);
    int depth;
    vec3 color = vec3(0.f);

   


    for( depth = 0 ; depth<pc_ray.max_depth ; depth++){

        hitPayload.material_idx = -1;
        traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        const  bool found_intersect = hitPayload.material_idx != -1;
        if(!found_intersect) {
            break;
        }
        
        SurfaceScatterEvent event = make_suface_scatter_event(hitPayload,direction.xyz);
        
        LightSample light_sample =  uniform_sample_one_light(rand4(seed), event,pc_ray.light_num);
          
        if(light_sample.pdf !=0 && !isBlack(light_sample.indensity))
          color +=  throughput * light_sample.indensity  /light_sample.pdf;
        
        
        float bsdf_pdf;
        vec3 f  = sample_bsdf(materials.m[event.material_idx],event,rand2(seed),bsdf_pdf);
        
        if(f == vec3(0) || bsdf_pdf == 0){
            break;
        }
        vec3 wi_world = to_world(event.frame,event.wi);
        throughput *= f / bsdf_pdf;
        direction = vec4(wi_world,0);
        origin = vec4(event.p,1);
    }
    
    
    if (pc_ray.frame_num > 0) {

        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
        vec4(mix(old_color, color, w), 1.f));
    } else {

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
    }
}
