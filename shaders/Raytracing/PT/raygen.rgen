#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require




#include "../common.glsl"
#include "path_commons.h"
#include "../util.glsl"

layout(location = 0) rayPayloadEXT HitPayload hitPayload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
layout(push_constant) uniform _PushConstantRay {PCPath pc_ray;};


#include "pt_commons.glsl"

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);


void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = scene_ubo.viewInverse * vec4(0,0,0,1);
    vec4 target = scene_ubo.projInverse * vec4(d.x, d.y, 1, 1) ;
    vec4 direction = scene_ubo.viewInverse*vec4(normalize(target.xyz / target.w), 0) ;

    uint rayFlags = gl_RayFlagsOpaqueEXT; 
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 throughput = vec3(1.0);
    int depth;
    vec3 color = vec3(0.f);

   


    for( depth = 0 ;  ; depth++){
        if(depth>= pc_ray.max_depth) {
            break;
        } 
        hitPayload.material_idx = -1;
        traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        const  bool found_intersect = hitPayload.material_idx != -1;
        if(!found_intersect) {
            break;
        }
        
        LightSample light_sample =  uniform_sample_one_light(rand4(seed), hitPayload.p, direction.xyz,hitPayload.n_s,pc_ray.light_num,hitPayload.material_idx);
          
        color += abs(light_sample.indensity) /light_sample.pdf;;
//        color = light_sample.indensity ;
        break;  
    }
    vec3 frameColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    
    color =  (frameColor * pc_ray.frame_num + color) / (pc_ray.frame_num + 1.0); ;
    
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));
}
