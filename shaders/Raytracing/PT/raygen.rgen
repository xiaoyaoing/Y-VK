#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require




#include "../common.glsl"
#include  "../bsdf.glsl"
#include "path_commons.h"
#include "../util.glsl"

layout(location = 0) rayPayloadEXT HitPayload hitPayload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
layout(push_constant) uniform _PushConstantRay { PCPath pc_ray; };;


#include "pt_commons.glsl"

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);



vec3 warp(vec3 v){
    return (v + 1.0f) / 2.f;
}

bool isBlack(vec3 v){
    return v.x == 0 && v.y == 0 && v.z == 0;
}

vec3 eval_light(const RTLight light, const vec3 p, const vec3 n_s, const vec3 w){
    return light.L;
}

vec3   uniform_sample_one_light(inout uvec4 seed, inout SurfaceScatterEvent event, const uint light_num){

    vec3 result = vec3(0);

    float light_choose_rand = rand1(seed);

    uint light_idx = uint(light_choose_rand * light_num);
    float light_choose_pdf = 1.0 / light_num;

    vec3 light_sample_rand = rand3(seed);

    const RTLight light = lights[light_idx];

    bool enable_sample_light = pc_ray.enable_sample_light > 0;
    bool enable_sample_bsdf = pc_ray.enable_sample_bsdf > 0;

    if (enable_sample_light)
    {
        LightSample light_sample = sample_li(light, event, light_sample_rand);
        if (!isBlack(light_sample.indensity) && light_sample.pdf != 0){
            //trace ray 
            any_hit_payload.hit = 1;
            traceRayEXT(tlas,
            gl_RayFlagsTerminateOnFirstHitEXT |
            gl_RayFlagsSkipClosestHitShaderEXT,
            0xFF, 1, 0, 1, event.p, EPS, light_sample.wi, light_sample.dist - EPS, 1);
            bool  visible = any_hit_payload.hit == 0;
            if (visible){
                uint material_idx = event.material_idx;
                event.wi = to_local(event.frame, light_sample.wi);
                float bsdf_pdf = pdf_bsdf(materials.m[material_idx], event);
                float light_mis_weight =enable_sample_bsdf? power_heuristic(light_sample.pdf, bsdf_pdf):1;
                result += light_sample.indensity * eval_bsdf(materials.m[material_idx], event) * light_mis_weight / light_sample.pdf;
            }
        }
    }

    if (enable_sample_bsdf)
    {
        BsdfSampleRecord record = sample_bsdf(materials.m[event.material_idx], event, rand2(seed));
        vec3 f = record.f;
        float bsdf_pdf = record.pdf;
        if (f != vec3(0) && bsdf_pdf != 0 && false){

            vec3 world_wi = to_world(event.frame, event.wi);
            //trace ray 
            hitPayload.prim_idx = -1;
            traceRayEXT(tlas,
            gl_RayFlagsOpaqueEXT,
            0xFF, 0, 0, 0, event.p, EPS, world_wi, 10000, 0);

            bool same_light = hitPayload.prim_idx == light.prim_idx;

            if (same_light){


                uint material_idx = event.material_idx;


                float light_pdf = 1.f/get_primitive_area(light.prim_idx) *  length(hitPayload.p-event.p) * length(hitPayload.p-event.p) / abs(dot(hitPayload.n_s, world_wi));


                float bsdf_mis_weight = enable_sample_light?power_heuristic(bsdf_pdf, light_pdf):1;

                uint triangle_count = prim_infos.p[light.prim_idx].index_count / 3;

                result += f * light.L * bsdf_mis_weight / bsdf_pdf;


            }
        }
    }

    return result;
}




vec3 Le(const SurfaceScatterEvent event){
    if (materials.m[event.material_idx].emissiveFactor != vec3(0) && get_cos_theta(event.wo)>0){
        return materials.m[event.material_idx].emissiveFactor;
    }
    return vec3(0);
}

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = scene_ubo.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = scene_ubo.projInverse * vec4(d.x, d.y, 1, 1);
    // origin =  vec4(0, 0, 0, 1);
    //   target = vec4(d.x, d.y, 100, 1);
    vec4 direction = scene_ubo.viewInverse*vec4(normalize(target.xyz / target.w), 0);

    //    origin.xzy = vec3(2.500000, 3.340000, 20.000000);
    //    direction.xzy = vec3(-0.406870, 0.032189, -0.912919);
    //debugPrintfEXT("origin and direction %f %f %f %f %f %f\n", origin.x, origin.y, origin.z, direction.x, direction.y, direction.z);

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 throughput = vec3(1.0);
    int depth;
    vec3 color = vec3(0.f);

    bool specular_bounce = true;


    for (depth = 0; depth<pc_ray.max_depth; depth++){

        hitPayload.material_idx = -1;
        traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        const  bool found_intersect = hitPayload.material_idx != -1;

        if (!found_intersect) {
            break;
        }



        RTLight light = lights[0];

        SurfaceScatterEvent event = make_suface_scatter_event(hitPayload, -direction.xyz);

        if (specular_bounce){
            color += throughput *  Le(event);;
        }

        vec3 direct_l =   uniform_sample_one_light(seed, event, pc_ray.light_num);


        if (depth >= pc_ray.min_depth)
        color +=  throughput *  direct_l;


        BsdfSampleRecord record = sample_bsdf(materials.m[event.material_idx], event, rand2(seed));

        specular_bounce = false;

        if (record.f == vec3(0) || record.pdf ==0){
            break;
        }
        vec3 wi_world = to_world(event.frame, event.wi);
        throughput *= record.f / record.pdf;
        direction = vec4(wi_world, 0);
        origin = vec4(event.p, 1);
    }


    if (pc_ray.frame_num > 0) {

        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
        vec4(mix(old_color, color, w), 1.f));
    } else {

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
    }
}
