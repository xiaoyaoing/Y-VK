#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require




#include "../common.glsl"
#include "path_commons.h"
#include "../util.glsl"

layout(location = 0) rayPayloadEXT HitPayload hitPayload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
layout(push_constant) uniform _PushConstantRay {PCPath pc_ray;};


#include "pt_commons.glsl"

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);

vec3 diffuse_f(const RTMaterial mat,const SurfaceScatterEvent event){
    vec3 albedo = mat.texture_id == -1 ? mat.albedo : texture(scene_textures[mat.texture_id],event.uv).rgb;
    return albedo * INV_PI * max(0,get_cos_theta(event.wi));
}

vec3 diffuse_sample(const RTMaterial mat,const vec2 rand ,inout SurfaceScatterEvent event,out float pdf){
    event.wi = square_to_cosine_hemisphere(rand);
    pdf = square_to_cosine_hemisphere_pdf(event.wi);
    return diffuse_f(mat,event);
}

float diffuse_pdf(const RTMaterial mat,const SurfaceScatterEvent event){
    return square_to_cosine_hemisphere_pdf(event.wi);
}


vec3 eval_bsdf(const RTMaterial mat,const SurfaceScatterEvent event) {
    vec3 f;
    f = diffuse_f(mat,event);
    return f;
}

float pdf_bsdf(const RTMaterial mat,const SurfaceScatterEvent event) {
    return diffuse_pdf(mat,event);
}

vec3  sample_bsdf(const RTMaterial mat,inout SurfaceScatterEvent event,const vec2 rand,out float pdf){
    return diffuse_sample(mat,rand,event,pdf);
}

vec3 warp(vec3 v){
    return (v + 1.0f) / 2.f;
}

bool isBlack(vec3 v){
    return v.x == 0 && v.y == 0 && v.z == 0;
}

vec3 eval_light(const RTLight light,const vec3 p,const vec3 n_s,const vec3 w){
    return light.L;
}

vec3   uniform_sample_one_light(inout uvec4 seed,inout SurfaceScatterEvent event ,const uint light_num){
    
    vec3 result = vec3(0);
    
    float light_choose_rand = rand1(seed); 
    
    uint light_idx = uint(light_choose_rand * light_num); 
    float light_choose_pdf = 1.0 / light_num;
    
    vec3 light_sample_rand = rand3(seed); 
     
    const RTLight light = lights[light_idx];
    
    LightSample light_sample = sample_li(light,event,light_sample_rand);   
    
    
    if(!isBlack(light_sample.indensity) && light_sample.pdf != 0){   
        //trace ray 
        any_hit_payload.hit = 1;
        traceRayEXT(tlas, 
        gl_RayFlagsTerminateOnFirstHitEXT |
        gl_RayFlagsSkipClosestHitShaderEXT,
        0xFF, 1, 0, 1, event.p, EPS, light_sample.wi, light_sample.dist - EPS, 1);
        bool  visible = any_hit_payload.hit == 0;
        if(visible){
            uint material_idx = event.material_idx;
            event.wi = to_local(event.frame, light_sample.wi);
            float bsdf_pdf = pdf_bsdf(materials.m[material_idx], event);

            float light_mis_weight = power_heuristic(light_sample.pdf, bsdf_pdf);
            result += light_sample.indensity * eval_bsdf(materials.m[material_idx], event) * light_mis_weight / light_sample.pdf;
        } 
    }

    {
        float bsdf_pdf;
        vec3 f = sample_bsdf(materials.m[event.material_idx],event,rand2(seed),bsdf_pdf);

        if(f != vec3(0) && bsdf_pdf != 0 && false ){
            
            vec3 world_wi = to_world(event.frame,event.wi); 
            //trace ray 
            hitPayload.prim_idx = -1;    
            traceRayEXT(tlas,
            gl_RayFlagsOpaqueEXT,
            0xFF, 0,0,0, event.p, EPS, world_wi, 10000, 0);
            
            bool same_light = hitPayload.prim_idx == light.prim_idx && hitPayload.triangle_idx == light_sample.triangle_idx;
            
            if(same_light){
             
                
                
                uint material_idx = event.material_idx;
                

                float light_pdf = 1.f/get_triangle_area(light.prim_idx,hitPayload.triangle_idx) *  length(hitPayload.p-event.p) * length(hitPayload.p-event.p) / abs(dot(hitPayload.n_s,world_wi)) ;
                

                float bsdf_mis_weight = power_heuristic(bsdf_pdf, light_pdf);
                
                uint triangle_count = prim_infos.p[light.prim_idx].index_count / 3;
                
                result += f * light.L * bsdf_mis_weight / bsdf_pdf  ;
                return  result;


            }
        }
    }
    
    return result;
}




vec3 Le(const SurfaceScatterEvent event){
    if(materials.m[event.material_idx].emissiveFactor != vec3(0) && get_cos_theta(event.wo)>0){
        return materials.m[event.material_idx].emissiveFactor;
    }
    return vec3(0);
}

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = scene_ubo.viewInverse * vec4(0,0,0,1);
    vec4 target = scene_ubo.projInverse * vec4(d.x, d.y, 1, 1) ;
    vec4 direction = scene_ubo.viewInverse*vec4(normalize(target.xyz / target.w), 0) ;

    uint rayFlags = gl_RayFlagsOpaqueEXT; 
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 throughput = vec3(1.0);
    int depth;
    vec3 color = vec3(0.f);
    
    bool specular_bounce = true;
    

    for( depth = 0 ; depth<pc_ray.max_depth ; depth++){

        hitPayload.material_idx = -1;
        traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
        const  bool found_intersect = hitPayload.material_idx != -1;
        
        if(!found_intersect) {
            break;
        }
        
        RTLight light = lights[0];
        
        SurfaceScatterEvent event = make_suface_scatter_event(hitPayload,-direction.xyz);

        if(specular_bounce){
            color += throughput *  Le(event);;
        }
        
        vec3 direct_l =   uniform_sample_one_light(seed, event,pc_ray.light_num);
        
     
        if(depth >= pc_ray.min_depth)
          color +=  throughput *  direct_l;
        
        
        float bsdf_pdf;
        vec3 f  = sample_bsdf(materials.m[event.material_idx],event,rand2(seed),bsdf_pdf);
        
        color += throughput *  f;
        
        specular_bounce = false;
        
        if(f == vec3(0) || bsdf_pdf == 0){
            break;
        }
        vec3 wi_world = to_world(event.frame,event.wi);
        throughput *= f / bsdf_pdf;
        direction = vec4(wi_world,0);
        origin = vec4(event.p,1);
    }
    
    
    if (pc_ray.frame_num > 0) {

        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
        vec4(mix(old_color, color, w), 1.f));
    } else {

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.f));
    }
}
