#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#include "ddgi_commons.h"

#define NUM_THREADS_X 16
#define NUM_THREADS_Y 16
#define PROBE_SIDE_LENGTH 16
#define PROBE_WITH_BORDER_SIDE 18

layout(binding = 3, set = 0) uniform SceneDescBuffer { SceneDesc scene_desc; };
layout(buffer_reference, std430, buffer_reference_align = 4) readonly buffer GBuffer_{ DDGIGBuffer d[]; };
GBuffer_ gbuffer = GBuffer_(scene_desc.gbuffer_addr);

layout(set = 2, binding = 0) uniform sampler2D radiance_map;
layout(set = 0, binding = 0) uniform _DDGIUboBuffer{ DDGIUbo ddgi_ubo; };
layout(push_constant) uniform _PushConstantRay { PCDDGI pc; };


#include "ddgi_sample.glsl"


// Returns +/-1
vec2  sign_not_zero(vec2 v)
{
    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
}

vec3 oct_decode(vec2 oct_coord) {
    vec3 v = vec3(oct_coord.xy, 1.0 - abs(oct_coord.x) - abs(oct_coord.y));
    if (v.z < 0) v.xy = (1.0 - abs(v.yx)) * sign_not_zero(v.xy);
    return normalize(v);
}

vec3 sample_irradiance_map(vec3 normal, vec3 position) {
//    vec3 irradiance = vec3(0.0);
//    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
//    vec3 bitangent = cross(normal, tangent);
//    for (int i = 0; i < CACHE_SIZE; i++) {
//        vec3 dir = ray_radiance[i].dir;
//        vec3 radiance = ray_radiance[i].radiance;
//        vec3 dir_tangent = vec3(dot(dir, tangent), dot(dir, bitangent), dot(dir, normal));
//        float weight = max(0.0, dot(dir, normal));
//        irradiance += radiance * weight;
//    }
//    return irradiance;
    return vec3(0.0);
}


layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y,
local_size_z = 1) in;
shared DDGIRayData ray_radiance[CACHE_SIZE];

const float tmax = 10000.0;
void main(){
    const uvec2 pixel_index  = gl_GlobalInvocationID.xy;
    const uint g_buffer_index = pixel_index.y * pc.size_x + pixel_index.x;
    vec3 normal = gbuffer.d[g_buffer_index].normal;
    vec3 position = gbuffer.d[g_buffer_index].position;
    vec3 radiance = sample_irradiance_map(normal, position);
    imageStore(ray_radiance_image, pixel_index, radiance);
}